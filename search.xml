<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces Round 975 (Div. 2)</title>
    <url>/2024/09/29/CF2019/</url>
    <content><![CDATA[<h3 id="Codeforces-Round-975-Div-2"><a href="#Codeforces-Round-975-Div-2" class="headerlink" title="Codeforces Round 975 (Div. 2)"></a>Codeforces Round 975 (Div. 2)</h3><p>最无语的一集，昨天晚上的Codeforces不是只作出来三题嘛。那个E题一直超时，但是我刚才又看了一下，结果很快就A了，大概就十几分钟。唉唉，昨天要是写出来了，那下场应该就可以比较轻松的上蓝了。不过毕竟情况不一样，心态也不一样了，本来可能打算看题解的。</p>
<p>自己写了一下过了，不过感觉写法不是很优啊，时限3000ms，我都代码1500ms，写的时候大概估算了下感觉应该不会超时，不过这个时间也挺大了，有点差了这个做法，但是看了下别人的代码，发现其实我大概离正解就差一点点了，还是可以的，有希望的哈。</p>
<p>这场只上了25分，也还行了，昨天carrot预测的是十几分来着……</p>
<p><img src="/../../img/2024_0929_00_36_05.png" alt="xxx"></p>
<p>这场感觉D和F应该很难补了吧，那把B和C的加一下吧。</p>
<h4 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h4><h6 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h6><p>给一个数组a，选择一些两两不相邻的数字，输出这些数字的个数+max 。max肯定要么在奇数位要么在偶数位，除了max，其他的你随便怎么取都可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    ll mx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>){</span><br><span class="line">        <span class="built_in">cmax</span>(mx,a[i]);</span><br><span class="line">        cnt++;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cmax</span>(ans,cnt+mx);</span><br><span class="line">    cnt=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>){</span><br><span class="line">        <span class="built_in">cmax</span>(mx,a[i]);</span><br><span class="line">        cnt++;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cmax</span>(ans,cnt+mx);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>



<h4 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h4><h6 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h6><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="66ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 29172 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">给</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">出</text></g><g data-mml-node="mtext" transform="translate(2000,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(2250,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mtext" transform="translate(2850,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(3100,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(4100,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(4350,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mtext" transform="translate(4922,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(5172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">轴</text></g><g data-mml-node="mi" transform="translate(6172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">上</text></g><g data-mml-node="mi" transform="translate(7172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(8172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">递</text></g><g data-mml-node="mi" transform="translate(9172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">增</text></g><g data-mml-node="mi" transform="translate(10172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(11172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(12172,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(13172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">你</text></g><g data-mml-node="mi" transform="translate(14172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">需</text></g><g data-mml-node="mi" transform="translate(15172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">要</text></g><g data-mml-node="mi" transform="translate(16172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">把</text></g><g data-mml-node="mi" transform="translate(17172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">这</text></g><g data-mml-node="mi" transform="translate(18172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">些</text></g><g data-mml-node="mi" transform="translate(19172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(20172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">两</text></g><g data-mml-node="mi" transform="translate(21172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">两</text></g><g data-mml-node="mi" transform="translate(22172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">连</text></g><g data-mml-node="mi" transform="translate(23172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(24172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">一</text></g><g data-mml-node="mi" transform="translate(25172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">条</text></g><g data-mml-node="mi" transform="translate(26172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">线</text></g><g data-mml-node="mi" transform="translate(27172,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">段</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(28172,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="67.83ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 29981 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">你</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">需</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">要</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">回</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">答</text></g><g data-mml-node="mtext" transform="translate(5000,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(5250,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mtext" transform="translate(5710,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(5960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">次</text></g><g data-mml-node="mi" transform="translate(6960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">询</text></g><g data-mml-node="mi" transform="translate(7960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">问</text></g><g data-mml-node="mi" transform="translate(8960,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(9960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">每</text></g><g data-mml-node="mi" transform="translate(10960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">次</text></g><g data-mml-node="mi" transform="translate(11960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">要</text></g><g data-mml-node="mi" transform="translate(12960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">回</text></g><g data-mml-node="mi" transform="translate(13960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">答</text></g><g data-mml-node="mi" transform="translate(14960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">有</text></g><g data-mml-node="mi" transform="translate(15960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">多</text></g><g data-mml-node="mi" transform="translate(16960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">少</text></g><g data-mml-node="mi" transform="translate(17960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mi" transform="translate(18960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(19960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">正</text></g><g data-mml-node="mi" transform="translate(20960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">好</text></g><g data-mml-node="mi" transform="translate(21960,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">被</text></g><g data-mml-node="mtext" transform="translate(22960,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(23210,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mtext" transform="translate(23731,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(23981,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mi" transform="translate(24981,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">线</text></g><g data-mml-node="mi" transform="translate(25981,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">段</text></g><g data-mml-node="mi" transform="translate(26981,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">覆</text></g><g data-mml-node="mi" transform="translate(27981,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">盖</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(28981,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g></g></g></svg></mjx-container></p>
<p>ok啊，很快猜到了插入数学公式的快捷键，然后也顺便知道了插入图像的快捷键。ctrl+shif+m，ctrl+shif+i。</p>
<p>这B题属实让我有点汗流浃背，五十多分钟才写出来。</p>
<h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p>首先我们只考虑单点的，第一个点一定答案是n-1，第二个点这时候被加了n-1了，它自己还要再加上n-2 。</p>
<p>所以我们可以看出来x[i]一定会被加上它前面的数字的数量*(它后面的数字的数量+1)+它后面的数量，即（i-1)*(n-i+1)+n-i 。</p>
<p>考虑a[i]和a[i+1]之间的数字，他们其实会被少加一些次，当a[i]前面的点和a[i]连的时候。</p>
<p>所以这之间的数字的值应该减去i-1 。用 map 存一下就行了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll n,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">x</span>(n<span class="number">+2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;x[i];</span><br><span class="line">    x[n<span class="number">+1</span>]=x[n]<span class="number">+1</span>;</span><br><span class="line">    map&lt;ll,ll&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        ll cur=(n<span class="number">+1</span>-i)*i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur&lt;=LNF)</span><br><span class="line">            mp[cur]+=<span class="number">1</span>;</span><br><span class="line">        cur-=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[i<span class="number">+1</span>]-x[i]&gt;<span class="number">1</span>&amp;&amp;cur&lt;=LNF){</span><br><span class="line">            mp[cur]+=x[i<span class="number">+1</span>]-x[i]<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(q--){</span><br><span class="line">        ll k;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;mp[k]&lt;&lt;" ";</span></span><br><span class="line">        cout&lt;&lt;(mp.<span class="built_in">contains</span>(k)?mp[k]:<span class="number">0</span>)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>建议用contains吧，我是赛后看了下好友的代码才感觉。之前没用过contains的，可以避免无效的插入。</p>
<h4 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h4><p>啊啊啊，CF又寄了。</p>
<h6 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h6><p>有 n 种卡片，你可以把这些卡片分成若干份，每一份必须数量相同且不能有相同的卡片，你可以买最多 k 张任意类型的卡片。输出最大的可能的每一份的卡牌的数量。</p>
<h6 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h6><p>当份数小于单种卡片的最大数量时，一定不行。所以我们只需要知道能不能使得份数大于最大的 a[i] 就能check，所以可以O(n) 解决。我刚开始没想到这样的，想到了一部分吧，写了二分，虽然现在看看是不是不太能二分（ ）。当时写的check也是一样的，O(1)，那为什么还要二分，然后改了就过了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    }</span><br><span class="line">    ll mx=*<span class="built_in">max_element</span>(<span class="built_in">ALL</span>(a));</span><br><span class="line">    <span class="keyword">auto</span> check=[&amp;](ll x){</span><br><span class="line">        <span class="comment">//最大值的个数 不能超过总个数</span></span><br><span class="line">        <span class="comment">//总个数是和加上k除以x</span></span><br><span class="line">        <span class="keyword">if</span>(k&lt;(x-(sum%x))%x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ll cnt=(sum+k)/x;</span><br><span class="line">        ll xx=mx*n;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=xx-sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> mx&lt;=cnt;</span><br><span class="line">    };</span><br><span class="line">    <span class="comment">//总共最多(sum+k)/x 组对吧</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i)){</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>



<h4 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h4><h6 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h6><p>给你一棵树，问要使得所有叶子节点深度相同，最少需要删除多少个点。</p>
<h6 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h6><p>考虑从距离大的遍历到距离小的，因为所有节点的长度一定是连续的，如果距离根节点最远的节点距离为max，那么一定存在与根节点距离为[1, max]的点。假设我们当前的距离为 i ，那么我们只需要删除距离根节点为 i+1 的点，再加上到距离为 i 的点必须要经过哪些点。用一个set来模拟即可。由于每个点最多只会被删除一遍，也最多只会被加入一遍，可以 guess 大概不会超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dis</span>(n<span class="number">+1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt</span>(n<span class="number">+1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">f</span>(n<span class="number">+1</span>);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">    map&lt;<span class="type">int</span>,set&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line">    <span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> now,<span class="type">int</span> pre)-&gt;<span class="type">void</span>{</span><br><span class="line">        cnt[dis[now]]++;</span><br><span class="line">        f[now]=pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u:adj[now]){</span><br><span class="line">            <span class="keyword">if</span>(u==pre) <span class="keyword">continue</span>;</span><br><span class="line">            dis[u]=dis[now]<span class="number">+1</span>;</span><br><span class="line">            mp[dis[u]].<span class="built_in">insert</span>(u);</span><br><span class="line">            st.<span class="built_in">insert</span>(dis[u]);</span><br><span class="line">            <span class="built_in">self</span>(self,u,now);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">dfs</span>(dfs,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;vis;</span><br><span class="line">    <span class="keyword">auto</span> dfs1=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> now){</span><br><span class="line">        <span class="keyword">if</span>(vis.<span class="built_in">contains</span>(now)) <span class="keyword">return</span>;</span><br><span class="line">        vis.<span class="built_in">insert</span>(now);</span><br><span class="line">        <span class="built_in">self</span>(self,f[now]);</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=mp.<span class="built_in">rbegin</span>();it!=mp.<span class="built_in">rend</span>();it++){</span><br><span class="line">        <span class="keyword">if</span>(it!=mp.<span class="built_in">rbegin</span>())</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:mp[it-&gt;fi<span class="number">+1</span>])</span><br><span class="line">                vis.<span class="built_in">erase</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:it-&gt;se)</span><br><span class="line">            <span class="built_in">dfs1</span>(dfs1,x);</span><br><span class="line">        <span class="built_in">cmax</span>(ans,<span class="built_in">sz</span>(vis));</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;n-ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>写得很有点差劲，但是刚才看到了别人的代码，感觉就差不多想到正解了……</p>
<p>唉唉，刚才去写了下，过了，577ms，不过其实我也看了好友的代码所以被提供了一点思路，但是总是比看题解好吧，看了下题解，感觉更清晰了，但是如果但看题解的话，我可能都有点难补感觉（ ）。</p>
<p>考虑就是，如果答案的叶子的深度为d，那么只有子树的节点的最大深度&gt;=d的点才会被留下来。</p>
<p>所以跟我们刚才的思路差不多，枚举深度d，那么子树上节点最大深度为d的节点需要被保留，而深度为d+1的节点将被删除。只需要两个数组单重循环即可完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector <span class="title">adj</span><span class="params">(n<span class="number">+1</span>,vector&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dis</span>(n<span class="number">+1</span>),<span class="built_in">mxdis</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> now,<span class="type">int</span> pre)-&gt;<span class="type">void</span>{</span><br><span class="line">        mxdis[now]=dis[now];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u:adj[now]){</span><br><span class="line">            <span class="keyword">if</span>(u==pre) <span class="keyword">continue</span>;</span><br><span class="line">            dis[u]=dis[now]<span class="number">+1</span>;</span><br><span class="line">            <span class="built_in">self</span>(self,u,now);</span><br><span class="line">            <span class="built_in">cmax</span>(mxdis[now],mxdis[u]);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">dfs</span>(dfs,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">c1</span>(n<span class="number">+1</span>),<span class="built_in">c2</span>(n<span class="number">+1</span>);<span class="comment">//c1代表距离为x的点的个数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c1[dis[i]]++,c2[mxdis[i]]++;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">        sum-=c1[i<span class="number">+1</span>],sum+=c2[i];</span><br><span class="line">        <span class="built_in">cmin</span>(ans,n-sum);</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>



<p>到这里就差不多了，现在快两点了，明天两节机房的课，明天再刷题。</p>
]]></content>
      <categories>
        <category>-Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 976 (Div. 2)</title>
    <url>/2024/10/01/CF2020/</url>
    <content><![CDATA[<p>很幸运的没有掉分，还上了八分，这把打得真唐爆了，看了大佬的 D 题的题解，真的妙啊。C题看了官方题解，越发觉得我自己写得史了。B题听群友讨论了，然后也明白了。。。幸好我打表了hhhhhhh。这场表现确实差吧，后面加油。</p>
<p><img src="/../../img/2024_1001_00_39_21.png" alt="嘻嘻"></p>
<p>因为发博客，截图得方便找到，于是又下载了截图插件，真挺爽的哈，这下很容易找到截图，而且截完之后可以直接贴到文件夹。系统自带的那个截图，只能贴到qq剪切板，不能贴到文件夹。命名规则和文件夹也能改，挺爽的，就是截图音效还没关，下次改下设置。名字叫share X，感觉真挺不错的。</p>
<h4 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h4><p>给你 n 和 k ，每次可以将 n - pow( k , x) ，x&gt;&#x3D;0 ，问最少多少次可以让 n 变成0 。确确实实很签到，但我确实 T 了两次，另外一次是网络问题多交了一次。因为网卡去镜像站交，结果看了下，主站也交上了……</p>
<p>我第二次就是加了个特判 k &#x3D; 1 , 然后就交了，后面发现自己太唐，难道不是 k 只能取一次方时就 break 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;n&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">            ans+=n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll cur=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur*k&gt;n)&#123;</span><br><span class="line">                n-=cur;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur*=k;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>越想越气，可能就是这题让我开始弘文（ ）。</p>
<h4 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h4><p>有 n 盏灯，从 1 到 n ，刚开始全为开启状态 ， 每一盏灯 i 会使它的所有倍数的灯的状态反转 ， 问至少要 n 为多少可以使得亮着的灯的数量为 k 。</p>
<p>实际上，很容易知道，如果一个数字的因子的数量为偶数那他就是亮着的，否则就是熄灭的。但是我赛时感觉似乎没啥规律，唐爆了。。。这不是很简单嘛。然后打标看了，发现答案依次是 k+1 , k+2 , …… , 数量也有一定规律， 就是两个+1 ，三个 +2 , ……</p>
<p>但是很容易发现，除了完全平方数，其他数字的因子数量一定为 2 ，因为如果你有因子 i ，那么一定有 n&#x2F;i ，且 i*i&#x3D;n ，所以一定是一一对应的，数量一定为偶数。</p>
<p>所以每有一个完全平方数，数量就得+1 , 我们假设答案里的完全平方数为 m 个，那么一定有 m*m-m &lt; k ，也就是说k+m个数字，会减掉 m 个，所以答案为 k+m ，二分一下即可。k+m &gt; m*m 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="comment">//只有完全平方数的因子个数为奇数</span></span><br><span class="line">    <span class="comment">//m*m-m&lt; k 我们知道了m 答案就是</span></span><br><span class="line">    ll lo=<span class="number">1</span>,hi=<span class="number">2</span>*INF;</span><br><span class="line">    <span class="keyword">while</span>(lo&lt;hi<span class="number">-1</span>)&#123;</span><br><span class="line">        ll m=lo+hi&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m*m-m&lt;k) lo=m;</span><br><span class="line">        <span class="keyword">else</span> hi=m;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;k+lo&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Problem-C"><a href="#Problem-C" class="headerlink" title="Problem C"></a>Problem C</h4><p>给出三个数字 b , c , d ，问是否存在 a 使得 (a|d)-(a&amp;c)&#x3D;d</p>
<p>赛时瞎写过了。看了题解发现自己真唐爆了，就是一个很简单的东西没看出来都。</p>
<p>可以发现每一位的值永远不可能为负，因为这样的话需要 前面 a&#x3D;0 , 后面 a&#x3D;1 ，显然不可能。</p>
<p>所以只需要独立考虑每一位 。如果这一位 a&#x3D;1 和 a&#x3D;0 都不能让表达式的这一位成立，那么就一定不行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a=<span class="number">0</span>,b,c,d;</span><br><span class="line">    cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">62</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> x=b&gt;&gt;i&amp;<span class="number">1</span>,y=c&gt;&gt;i&amp;<span class="number">1</span>,z=d&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==z) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span>-y==z) a|=<span class="number">1LL</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h4><p>有 n 个点，给你 m 次操作，每次操作给出三个数字，idx , d , k ，需要将 idx , idx+d , idx+2d , … ,idx+kd ，两两连起来。问最后有多少个连通分量。</p>
<p>由于 d 的值很小，所以如果一个数字会被连的话，那么它前10 个位置一定有连它的。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==f[x]?x:f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        f[i]=i;</span><br><span class="line">    <span class="function">vector <span class="title">c</span><span class="params">(n<span class="number">+1</span>,array&lt;<span class="type">int</span>,<span class="number">11</span>&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> id,d,k;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;d&gt;&gt;k;</span><br><span class="line">        <span class="built_in">cmax</span>(c[id][d],k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-j&lt;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(c[i-j][j])&#123;</span><br><span class="line">                f[<span class="built_in">find</span>(i)]=f[<span class="built_in">find</span>(i-j)];</span><br><span class="line">                <span class="built_in">cmax</span>(c[i][j],c[i-j][j]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">find</span>(i)==i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c[ i ][ j ]表示从 i 开始连，步长为 j 的最大的 k , 如果你前面的 j 距离的点，k&gt;0 ，那么你就会被连到一起。</p>
<p>太妙了啊。。。困困。。。</p>
<p>没有上蓝，但我还是决定明天回家，票已经买好了，下午四点的，七点到家。今天一天没刷题，白天满课，晚上干啥了来着。。。好像啥也没干，唐爆了，明天白天务必写一些。</p>
]]></content>
      <categories>
        <category>-Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>弄博客似乎有点难</title>
    <url>/2024/09/28/%E5%BC%84%E5%8D%9A%E5%AE%A2%E7%9C%9F%E9%9A%BE%E5%95%8A/</url>
    <content><![CDATA[<p>整了一天多的时间……但是没啥变化的。</p>
<p>不过感觉说白了，博客真的就是写给自己看的。别人很少会看吧，不过这样也不错，自己写自己的自己看。</p>
<p>试试效果咋样先。OK，成功了，我是真的头昏了都，搞了这么久，终于成功了hhhhhhh。我也可以发博客了捏。感觉我不会写多少。但是希望能多写点吧，好看一点。</p>
<p>呃呃呃，至少这个比单纯写markdown好看一点吧。之前刷题，搜题解看到有的大佬的github博客真的很好看很好看，题解也写得很好。以后再慢慢研究下吧。</p>
<p>准备以后更新一些题解和想法，希望可以成为算法竞赛高手和前端高手（ ）。现在感觉根本不会设置这个博客，看文档都要看不懂了，我怎么这么唐（ ）。慢慢学习吧，现在起码弄得差不多了，以后慢慢改就是了。从昨天下午到现在，除了昨天晚上打CF和睡觉，基本一直在整这个b博客（ ），但是现在也就这样，其实就是初始的样子吧。</p>
<p>感觉可能是我的加速器不太行，然后也不会设代理和镜像啥的，不过总算也是弄好了，但是现在对于这个一点也不懂，让我很难受。</p>
<p><img src="/../../img/24Sep8_1.png" alt="嘻嘻"></p>
<p>唉唉，还得研究下markdown嘛可能，先差不多这样就行了吧。真的可以坚持写博客嘛（ ）。可以的，我感觉我现在只是因为觉得新鲜吧。差不多这样了，先去泡碗面吃，然后刷一下题。一天没写了，起码得把昨天的E题补了，昨天的D比E难来着。</p>
<p>额，更牛了，刚才一直传上去就看不到图片了，然后搜了下，貌似只能以..&#x2F;..&#x2F;img&#x2F;xxx.png这样的路径来添加图片才能在博客上显示，但是这样的话md文档就看不了图片了啊！！！！！</p>
<p>唉唉，也还行，勉强也能接受的，因为md文档，也只能发压缩包给别人或者导出成pdf才能给别人看到图片吧，或者用url，到这里应该差不多都搞清楚了，就是添加图片稍微有一点点麻烦，看来是不是还是需要一个截图插件才行，我感觉需要一个好整理分类截图和命名规则好点的截图插件，不然很烦吧。</p>
<p>总之第一篇博客是能发出去了，明天无论如何务必刷一天题。</p>
]]></content>
  </entry>
  <entry>
    <title>本来差39分上蓝，现在应该不止了……</title>
    <url>/2024/09/30/%E6%9C%AC%E6%9D%A5%E5%B7%AE39%E5%88%86%E4%B8%8A%E8%93%9D%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%BA%94%E8%AF%A5%E4%B8%8D%E6%AD%A2%E4%BA%86%E2%80%A6%E2%80%A6/</url>
    <content><![CDATA[<p>唉唉，打完了这场Codeforces，本来指望着这场打完了上蓝名的，本来差39分。这下，感觉打完了差得更多了。</p>
<p><img src="/../../img/2024_0930_01_44_46.png" alt="2024_0930_01_44_46"></p>
<p>还在pending，希望别FST了，B我打表找规律的，C我也不知道怎么瞎搞就交了下就过了……我本来感觉这个C我怎么都不该对的，不过现在看其实人挺多的。A题wa了三次，最不该的。网络问题多了一次，另外两次完全是我自己的问题。明明这么简单的一个题，唉唉。也看运气吧CF，如果我真的有蓝名水平，那么我只要打得多一定会上的。这会上不了没啥的，掉分就加训呗。</p>
<p>我的训练量和强度其实还是远远不够，感觉基本没训到什么，就应该疯狂板刷1600-2000，是得稍微高点吧，这场的D是不是分数起码1800来着，我猜的。没事，慢慢来吧。</p>
<p>虽然没有上蓝名是有点失落，但是我会好好加油的，那国庆就不回去了，看看能刷多少题，虽然感觉刷不了多少，但我尽力吧。其实还是急了点吧hhh，练的量还不算太够，本来期望是11月上蓝，再给一个月差不多了，研究一下，这个D题我确实就是写不出来，没办法，明天再看看吧，明天一天满课的。但是之后就国庆假期了就爽了。</p>
<p>我要更稳一点，然后这种赛时1000-2000人过的题目，也得想办法取突破吧，对于目前的我确实是有点难，但是起码现在我一定会补了，那我就得更多补一点。想赛时写出1000-2000人过的题，那我是不是就该多补一题呢，嗯嗯嗯。加油吧！！！</p>
<p>再看看补点什么算法和数据结构，我目前真的感觉我打比赛还真没用到过什么算法，当然我也不会什么算法来着。多补一些难题我应该？啊啊啊啊啊啊，但是这个对我已经够难了。感觉有点不知道写什么题？但是实际上，我有很多时间可以写题吧，怎么不多写一点，肯定有用吧。</p>
<p>睡了睡了，然后就是，就算我现在打CF用不到什么算法可能，但是我一定得去学吧，不学真就废了，然后多刷题，多刷CF我也一定可以上分只要刷得够多。</p>
<p>感觉自己写得很混乱。总之我会加油，尽量要保持一直在学东西吧，我把自己学习的记录发到博客上，也好让大家监督我或者看我笑话。</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
