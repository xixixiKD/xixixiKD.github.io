<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces Round 975 (Div. 2)</title>
    <url>/2024/09/29/Codeforces-Round-975-Div-2/</url>
    <content><![CDATA[<h3 id="Codeforces-Round-975-Div-2"><a href="#Codeforces-Round-975-Div-2" class="headerlink" title="Codeforces Round 975 (Div. 2)"></a>Codeforces Round 975 (Div. 2)</h3><p>最无语的一集，昨天晚上的Codeforces不是只作出来三题嘛。那个E题一直超时，但是我刚才又看了一下，结果很快就A了，大概就十几分钟。唉唉，昨天要是写出来了，那下场应该就可以比较轻松的上蓝了。不过毕竟情况不一样，心态也不一样了，本来可能打算看题解的。</p>
<p>自己写了一下过了，不过感觉写法不是很优啊，时限3000ms，我都代码1500ms，写的时候大概估算了下感觉应该不会超时，不过这个时间也挺大了，有点差了这个做法，但是看了下别人的代码，发现其实我大概离正解就差一点点了，还是可以的，有希望的哈。</p>
<p>这场只上了25分，也还行了，昨天carrot预测的是十几分来着……</p>
<p><img src="/../../img/2024_0929_00_36_05.png" alt="xxx"></p>
<p>这场感觉D和F应该很难补了吧，那把B和C的加一下吧。</p>
<h4 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h4><h6 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h6><p>给一个数组a，选择一些两两不相邻的数字，输出这些数字的个数+max 。max肯定要么在奇数位要么在偶数位，除了max，其他的你随便怎么取都可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    ll mx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">cmax</span>(mx,a[i]);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cmax</span>(ans,cnt+mx);</span><br><span class="line">    cnt=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">cmax</span>(mx,a[i]);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cmax</span>(ans,cnt+mx);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h4><h6 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h6><p>$$<br>\begin{flalign*}<br>&amp;给出\ n\ 个\ x\ 轴上的递增的点，你需要把这些点两两连成一条线段。\<br>&amp;你需要回答\ q\ 次询问，每次要回答有多少个点正好被\ k\ 个线段覆盖。\<br>\end{flalign*}<br>$$</p>
<p>ok啊，很快猜到了插入数学公式的快捷键，然后也顺便知道了插入图像的快捷键。ctrl+shif+m，ctrl+shif+i。</p>
<p>这B题属实让我有点汗流浃背，五十多分钟才写出来。</p>
<h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p>首先我们只考虑单点的，第一个点一定答案是n-1，第二个点这时候被加了n-1了，它自己还要再加上n-2 。</p>
<p>所以我们可以看出来x[i]一定会被加上它前面的数字的数量*(它后面的数字的数量+1)+它后面的数量，即（i-1)*(n-i+1)+n-i 。</p>
<p>考虑a[i]和a[i+1]之间的数字，他们其实会被少加一些次，当a[i]前面的点和a[i]连的时候。</p>
<p>所以这之间的数字的值应该减去i-1 。用 map 存一下就行了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">x</span>(n<span class="number">+2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;x[i];</span><br><span class="line">    x[n<span class="number">+1</span>]=x[n]<span class="number">+1</span>;</span><br><span class="line">    map&lt;ll,ll&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll cur=(n<span class="number">+1</span>-i)*i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur&lt;=LNF)</span><br><span class="line">            mp[cur]+=<span class="number">1</span>;</span><br><span class="line">        cur-=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[i<span class="number">+1</span>]-x[i]&gt;<span class="number">1</span>&amp;&amp;cur&lt;=LNF)&#123;</span><br><span class="line">            mp[cur]+=x[i<span class="number">+1</span>]-x[i]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        ll k;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;mp[k]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        cout&lt;&lt;(mp.<span class="built_in">contains</span>(k)?mp[k]:<span class="number">0</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议用contains吧，我是赛后看了下好友的代码才感觉。之前没用过contains的，可以避免无效的插入。</p>
<h4 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h4><p>啊啊啊，CF又寄了。</p>
<h6 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h6><p>有 n 种卡片，你可以把这些卡片分成若干份，每一份必须数量相同且不能有相同的卡片，你可以买最多 k 张任意类型的卡片。输出最大的可能的每一份的卡牌的数量。</p>
<h6 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h6><p>当份数小于单种卡片的最大数量时，一定不行。所以我们只需要知道能不能使得份数大于最大的 a[i] 就能check，所以可以O(n) 解决。我刚开始没想到这样的，想到了一部分吧，写了二分，虽然现在看看是不是不太能二分（ ）。当时写的check也是一样的，O(1)，那为什么还要二分，然后改了就过了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll mx=*<span class="built_in">max_element</span>(<span class="built_in">ALL</span>(a));</span><br><span class="line">    <span class="keyword">auto</span> check=[&amp;](ll x)&#123;</span><br><span class="line">        <span class="comment">//最大值的个数 不能超过总个数</span></span><br><span class="line">        <span class="comment">//总个数是和加上k除以x</span></span><br><span class="line">        <span class="keyword">if</span>(k&lt;(x-(sum%x))%x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ll cnt=(sum+k)/x;</span><br><span class="line">        ll xx=mx*n;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=xx-sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> mx&lt;=cnt;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//总共最多(sum+k)/x 组对吧</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h4><h6 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h6><p>给你一棵树，问要使得所有叶子节点深度相同，最少需要删除多少个点。</p>
<h6 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h6><p>考虑从距离大的遍历到距离小的，因为所有节点的长度一定是连续的，如果距离根节点最远的节点距离为max，那么一定存在与根节点距离为[1, max]的点。假设我们当前的距离为 i ，那么我们只需要删除距离根节点为 i+1 的点，再加上到距离为 i 的点必须要经过哪些点。用一个set来模拟即可。由于每个点最多只会被删除一遍，也最多只会被加入一遍，可以 guess 大概不会超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dis</span>(n<span class="number">+1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt</span>(n<span class="number">+1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">f</span>(n<span class="number">+1</span>);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">    map&lt;<span class="type">int</span>,set&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line">    <span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> now,<span class="type">int</span> pre)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">        cnt[dis[now]]++;</span><br><span class="line">        f[now]=pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u:adj[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(u==pre) <span class="keyword">continue</span>;</span><br><span class="line">            dis[u]=dis[now]<span class="number">+1</span>;</span><br><span class="line">            mp[dis[u]].<span class="built_in">insert</span>(u);</span><br><span class="line">            st.<span class="built_in">insert</span>(dis[u]);</span><br><span class="line">            <span class="built_in">self</span>(self,u,now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(dfs,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;vis;</span><br><span class="line">    <span class="keyword">auto</span> dfs1=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis.<span class="built_in">contains</span>(now)) <span class="keyword">return</span>;</span><br><span class="line">        vis.<span class="built_in">insert</span>(now);</span><br><span class="line">        <span class="built_in">self</span>(self,f[now]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=mp.<span class="built_in">rbegin</span>();it!=mp.<span class="built_in">rend</span>();it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it!=mp.<span class="built_in">rbegin</span>())</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:mp[it-&gt;fi<span class="number">+1</span>])</span><br><span class="line">                vis.<span class="built_in">erase</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:it-&gt;se)</span><br><span class="line">            <span class="built_in">dfs1</span>(dfs1,x);</span><br><span class="line">        <span class="built_in">cmax</span>(ans,<span class="built_in">sz</span>(vis));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写得很有点差劲，但是刚才看到了别人的代码，感觉就差不多想到正解了……</p>
<p>唉唉，刚才去写了下，过了，577ms，不过其实我也看了好友的代码所以被提供了一点思路，但是总是比看题解好吧，看了下题解，感觉更清晰了，但是如果但看题解的话，我可能都有点难补感觉（ ）。</p>
<p>考虑就是，如果答案的叶子的深度为d，那么只有子树的节点的最大深度&gt;&#x3D;d的点才会被留下来。</p>
<p>所以跟我们刚才的思路差不多，枚举深度d，那么子树上节点最大深度为d的节点需要被保留，而深度为d+1的节点将被删除。只需要两个数组单重循环即可完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector <span class="title">adj</span><span class="params">(n<span class="number">+1</span>,vector&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dis</span>(n<span class="number">+1</span>),<span class="built_in">mxdis</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> now,<span class="type">int</span> pre)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">        mxdis[now]=dis[now];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u:adj[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(u==pre) <span class="keyword">continue</span>;</span><br><span class="line">            dis[u]=dis[now]<span class="number">+1</span>;</span><br><span class="line">            <span class="built_in">self</span>(self,u,now);</span><br><span class="line">            <span class="built_in">cmax</span>(mxdis[now],mxdis[u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(dfs,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">c1</span>(n<span class="number">+1</span>),<span class="built_in">c2</span>(n<span class="number">+1</span>);<span class="comment">//c1代表距离为x的点的个数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c1[dis[i]]++,c2[mxdis[i]]++;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        sum-=c1[i<span class="number">+1</span>],sum+=c2[i];</span><br><span class="line">        <span class="built_in">cmin</span>(ans,n-sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里就差不多了，现在快两点了，明天两节机房的课，明天再刷题。</p>
]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>弄博客似乎有点难</title>
    <url>/2024/09/28/%E5%BC%84%E5%8D%9A%E5%AE%A2%E7%9C%9F%E9%9A%BE%E5%95%8A/</url>
    <content><![CDATA[<p>整了一天多的时间……但是没啥变化的。</p>
<p>不过感觉说白了，博客真的就是写给自己看的。别人很少会看吧，不过这样也不错，自己写自己的自己看。</p>
<p>试试效果咋样先。OK，成功了，我是真的头昏了都，搞了这么久，终于成功了hhhhhhh。我也可以发博客了捏。感觉我不会写多少。但是希望能多写点吧，好看一点。</p>
<p>呃呃呃，至少这个比单纯写markdown好看一点吧。之前刷题，搜题解看到有的大佬的github博客真的很好看很好看，题解也写得很好。以后再慢慢研究下吧。</p>
<p>准备以后更新一些题解和想法，希望可以成为算法竞赛高手和前端高手（ ）。现在感觉根本不会设置这个博客，看文档都要看不懂了，我怎么这么唐（ ）。慢慢学习吧，现在起码弄得差不多了，以后慢慢改就是了。从昨天下午到现在，除了昨天晚上打CF和睡觉，基本一直在整这个b博客（ ），但是现在也就这样，其实就是初始的样子吧。</p>
<p>感觉可能是我的加速器不太行，然后也不会设代理和镜像啥的，不过总算也是弄好了，但是现在对于这个一点也不懂，让我很难受。</p>
<p><img src="/../../img/24Sep8_1.png" alt="嘻嘻"></p>
<p>唉唉，还得研究下markdown嘛可能，先差不多这样就行了吧。真的可以坚持写博客嘛（ ）。可以的，我感觉我现在只是因为觉得新鲜吧。差不多这样了，先去泡碗面吃，然后刷一下题。一天没写了，起码得把昨天的E题补了，昨天的D比E难来着。</p>
<p>额，更牛了，刚才一直传上去就看不到图片了，然后搜了下，貌似只能以..&#x2F;..&#x2F;img&#x2F;xxx.png这样的路径来添加图片才能在博客上显示，但是这样的话md文档就看不了图片了啊！！！！！</p>
<p>唉唉，也还行，勉强也能接受的，因为md文档，也只能发压缩包给别人或者导出成pdf才能给别人看到图片吧，或者用url，到这里应该差不多都搞清楚了，就是添加图片稍微有一点点麻烦，看来是不是还是需要一个截图插件才行，我感觉需要一个好整理分类截图和命名规则好点的截图插件，不然很烦吧。</p>
<p>总之第一篇博客是能发出去了，明天无论如何务必刷一天题。</p>
]]></content>
  </entry>
</search>
